## AI Submissions for Mon Jan 12 2026 {{ 'date': '2026-01-12T17:16:24.990Z' }}

### Cowork: Claude Code for the rest of your work

#### [Submission URL](https://claude.com/blog/cowork-research-preview) | 1160 points | by [adocomplete](https://news.ycombinator.com/user?id=adocomplete) | [501 comments](https://news.ycombinator.com/item?id=46593022)

Anthropic announces Cowork: Claude Code’s autonomy for everyday work (research preview)

- What it is: Cowork is a new mode in the Claude macOS app that lets the model read, edit, and create files inside a folder you choose—bringing Claude Code’s “agentic” workflow to non‑coding tasks.
- How it works: You grant folder access, set a task, and Claude plans and executes with status updates. It can reorganize downloads, turn receipt screenshots into a spreadsheet, or draft a report from scattered notes. You can queue tasks (runs in parallel), avoid constant context wrangling, and keep working while it proceeds.
- Extensibility: Works with your existing connectors and a first set of “skills” for producing docs, decks, and other files. Paired with Claude in Chrome, it can handle tasks requiring the browser.
- Safety model: You control which folders/connectors it can see; Claude asks before significant actions. Still, it can perform destructive operations (e.g., delete files) if instructed. Anthropic flags prompt‑injection risks and recommends clear instructions and caution; more guidance is in their Help Center.
- Availability: Research preview for Claude Max subscribers on macOS today. Windows and cross‑device sync are planned; waitlist available for other plans.
- Why it matters: Shifts Claude from chat into a practical desktop coworker, reducing copy/paste friction and enabling end‑to‑end task completion for non‑dev workflows.

Link: https://claude.com/blog/cowork-research-preview

**Discussion Summary:**

Technical discussion focused heavily on the security implications of granting an LLM agent autonomy over local files, specifically regarding prompt injection, data exfiltration, and privacy.

*   **Prompt Injection Risks:** Users expressed skepticism regarding the safety model, specifically the risk of **indirect prompt injection** (where the model reads a file containing malicious hidden instructions). One commenter noted that Anthropic’s support page puts the burden on the user to "avoid granting access to sensitive information" and "monitor for suspicious actions," which they argued is an unsafe expectation for non-technical users.
*   **Sandbox & Exfiltration Vectors:** There was a deep dive into the underlying architecture; testing by `smnw` revealed the environment operates as a **full Linux (Ubuntu) container** running via Apple’s Virtualization framework. While the sandbox has a default allow-list for domains, users demonstrated that data could still be exfiltrated via **DNS tunneling** (e.g., using `dig` to send data to a malicious server).
*   **Privacy Implications:** Participants clarified that, according to Anthropic's Terms of Service, files within mounted folders are treated as "Inputs." This means granting the agent access to a folder effectively sends that data to Anthropic, raising concerns about using the tool with proprietary or sensitive documents.
*   **Agent Control & Safety:** Anecdotes highlighted the difficulty of constraining the agent's behavior. One user reported that despite instructions to focus on a specific subdirectory, the agent attempted to access parent directories. Others suggested the tool needs built-in "rollback" capabilities (like ZFS snapshots or git integration) to mitigate accidental destructive actions.

### TimeCapsuleLLM: LLM trained only on data from 1800-1875

#### [Submission URL](https://github.com/haykgrigo3/TimeCapsuleLLM) | 695 points | by [admp](https://news.ycombinator.com/user?id=admp) | [287 comments](https://news.ycombinator.com/item?id=46590280)

TimeCapsule LLM: training models on era-bounded corpora to cut modern bias

- What it is: An open-source experiment to train language models exclusively on texts from specific places and time periods (e.g., London, 1800–1875) so the model adopts the era’s voice, vocabulary, and worldview—rather than role‑playing a historical persona.
- How it’s built: Early versions use nanoGPT; v1 switches to Microsoft’s Phi-1.5; v2 uses llama-for-causal-lm. The repo includes data pipelines pulling from Internet Archive, plus a London corpus. MIT licensed.
- Why it’s interesting: “Time-bounded” training offers a way to reduce modern framing and bias when generating historical prose or analysis, producing outputs that feel native to the period.
- Results so far:
  - v0 (≈187MB data): convincingly archaic tone but largely incoherent.
  - v0.5: big jump in grammar and Victorian style, still hallucinates; OCR artifacts leak into outputs (“Digitized by Google”).
  - v1: first signs of grounded recall—ties “year of our Lord 1834” to London protests.
  - v2 mini-evals (15GB sample, 10k steps): tokenization glitch introduces spaced-out syllables; corrected text shows period flavor but remains meandering.
- Trade-offs: Authentic style vs. factual reliability; small and noisy historical datasets make grounding hard. Tokenization and OCR cleanup are clear next steps.
- Status: 1.5k stars, 44 forks. Multilingual README. Includes scripts, dataset IDs, and sample outputs/images.
- Potential uses: Period-accurate writing, education, historical simulation—anywhere modern phrasing and assumptions get in the way of “speaking from the past.”

**Scientific Discovery and the "Einstein Test"**
The most active thread debates a thought experiment proposed by users: if a model trained exclusively on pre-1900 data can derive Special Relativity or Quantum Mechanics when prompted, does this constitute proof of AGI?
*   **The Synthesis Argument:** Some argue that late 19th-century physics already contained the necessary components (Michelson-Morley experiments, Lorentz transformations, etc.). If an LLM creates Relativity from this, it may simply prove that the theory was an inevitable synthesis of existing data rather than a "quantum leap" of reasoning.
*   **Defining Genius:** This sparked a philosophical debate regarding the nature of scientific progress. Users discussed whether figures like Einstein produced unique structural insights or merely completed a puzzle that was already 99% solved by the scientific *Zeitgeist*.
*   **Paradigm Shifts:** Commenters referenced Thomas Kuhn, questioning if an LLM can bridge "incommensurate paradigms" (e.g., jumping from Newtonian gravity to composition-based spectral analysis) without the empirical evidence that usually drives such shifts.
*   **Research Utility:** Beyond AGI benchmarks, users seeing value in using era-bounded LLMs as "Mycrofts" (armchair detectives)—tools that can read vast historical corpora faster than humans to identify missed connections or viable hypotheses that were overlooked at the time.

### Show HN: AI in SolidWorks

#### [Submission URL](https://www.trylad.com) | 180 points | by [WillNickols](https://news.ycombinator.com/user?id=WillNickols) | [98 comments](https://news.ycombinator.com/item?id=46591100)

LAD (Language-Aided Designer) is a new SolidWorks add-in that lets you drive CAD with natural language. Describe what you want in plain English and it translates that into sketches, features, and even assemblies—checking the model’s screenshots and feature tree to verify steps and auto-correct mistakes.

Notable features
- Design from docs and images: Feed it specification PDFs, reference images, or previous parts/assemblies and it will read and use them.
- Macro support: Can write and run VBA macros, looking up SolidWorks API docs/examples to tailor code for niche tasks and reproducibility.
- Guardrails: Per-command permissioning, rule-based guidance, and checkpointed versioning so you can revert unwanted changes.
- Context awareness: Natively tracks model state and compresses long conversations to stay on task.

What’s new (v1.1, 2026-01-11)
- Planning mode
- Macro writing/running
- Sketch issue detection/reporting
- Faster caching and AI context improvements
- Bug fixes

Other notes
- Integrates directly in SolidWorks; Windows download available.
- Referral program: “Refer a friend” for free months of LAD Pro for both parties.
- The site lists common questions (pricing, data collection, compatibility) but doesn’t answer them on the page.

**LAD (Language-Aided Designer) for SolidWorks**
LAD is a newly updated SolidWorks add-in (v1.1) that enables engineers to drive CAD design using natural language. The tool translates plain English instructions, specification PDFs, and reference images into native SolidWorks sketches, features, and assemblies. Key capabilities include the ability to write and run VBA macros via API lookups, a "planning mode" for complex tasks, and robust guardrails that allow users to preview and revert AI-generated changes. The system checks model screenshots and feature trees to verify steps and auto-correct errors. Windows-based and integrated directly into SolidWorks, LAD aims to bridge the gap between documentation and 3D modeling.

**Discussion Summary**
The Hacker News discussion revolves around the steep learning curve of SolidWorks, the viability of AI in precision engineering, and the broader landscape of CAD software.

*   **SolidWorks Usability vs. Power:** A significant portion of the debate focuses on the SolidWorks user experience. Some users describe the software as non-intuitive and frustrating for beginners, citing broken tutorials, "hidden" features, and a UI built on decades of conventions that feel archaic. Conversely, veteran users argue that while the learning curve is steep (taking months or years), SolidWorks is arguably the most flexible and efficient tool once mastered. They note that the UI stability allows professionals to maintain muscle memory over decades.
*   **The "Amalgamation" Problem:** Commenters noted that SolidWorks feels like an amalgamation of various regional software and plugins acquired over time, leading to inconsistent interfaces. This was contrasted with newer, cloud-native alternatives like Onshape (praised for collaboration and Linux support) and Fusion 360 (praised for approachability, though criticized for vendor lock-in and pricing strategies).
*   **AI Reliability in CAD:** There is skepticism regarding AI-driven modeling. One user expressed fear that an AI might misinterpret a prompt and create subtle model errors that take longer to debug than simply building the part from scratch. The LAD creator (*WillNickols*) clarifies that the tool captures model snapshots before every action, allowing users to instantly revert mistakes.
*   **Related Projects:** The thread spawned discussions on similar AI hardware efforts. One user (*mkyls*) detailed an ambitious project attempting to automate the entire product development pipeline (PCB, enclosure, firmware) using AI, while another (*pnys*) mentioned "GrandpaCAD," a text-to-CAD tool originally designed to help seniors build simple models.
*   **Stagnation vs. Stability:** Users observed that the core SolidWorks interface hasn't changed much in 15 years. While some see this as a lack of innovation compared to web-based tools, others argue that for mission-critical industrial software (like Catia and Matlab), UI stability is a feature, not a bug. However, the recent push toward the "3DEXPERIENCE" cloud platform was universally criticized as intrusive.

### Show HN: Yolobox – Run AI coding agents with full sudo without nuking home dir

#### [Submission URL](https://github.com/finbarr/yolobox) | 110 points | by [Finbarr](https://news.ycombinator.com/user?id=Finbarr) | [80 comments](https://news.ycombinator.com/item?id=46592344)

Yolobox: let AI coding agents go “full send” without nuking your home directory

What it is:
- A Go-based wrapper that runs AI coding agents inside a Docker/Podman container where your project is mounted at /workspace, but your host $HOME isn’t mounted by default.
- Ships a batteries-included image with Claude Code, Gemini CLI, OpenAI Codex, OpenCode, Node 22, Python 3, build tools, git/gh, and common CLI utilities.

Why it matters:
- Full‑auto AI agents are powerful but risky; one bad command can trash your machine. Yolobox gives them sudo inside a sandbox while keeping your actual home directory off-limits, so you can let them refactor, install, and run without constant approvals.

Notable features:
- YOLO mode aliases: claude → claude --dangerously-skip-permissions, codex → codex --dangerously-bypass-approvals-and-sandbox, gemini → gemini --yolo.
- Persistent volumes so tools/configs survive across sessions; extra mounts and env vars via flags or config files.
- Safety toggles: --no-network, --readonly-project (writes to /output), optional SSH agent forwarding, one-time --claude-config sync.
- Auto-forwards common API keys (Anthropic, OpenAI, Gemini, OpenRouter) and GitHub tokens if present.
- Runs on macOS (Docker Desktop/OrbStack/Colima) and Linux (Docker/Podman). Note: Claude Code needs 4GB+ Docker RAM; bump Colima from its 2GB default.

Security model (read the fine print):
- Protects against accidental rm -rf ~ and host credential grabs by not mounting $HOME.
- It’s still a container: not protection against kernel/container escape exploits or a truly adversarial agent. For stronger isolation, use a VM.

Quick start:
- Install: curl -fsSL https://raw.githubusercontent.com/finbarr/yolobox/master/install.sh | bash
- In your repo: yolobox (interactive shell) or yolobox run claude

Config:
- ~/.config/yolobox/config.toml for globals; .yolobox.toml per project. Precedence: CLI flags > project config > global config.

Repo: github.com/finbarr/yolobox (MIT)

**Yolobox: let AI coding agents go “full send” without nuking your home directory**

**Top HN Story**
Yolobox is a Go-based wrapper designed to run autonomous AI coding agents—like Claude Code, Gemini, and OpenAI Codex—inside ephemeral Docker or Podman containers. The tool addresses the risks associated with giving AI agents "full auto" permission by mounting the current project directory into the container while keeping the host’s `$HOME` directory and sensitive credentials inaccessible.

It acts as a "batteries-included" sandbox, pre-installed with Node, Python, and common build tools. It offers "YOLO mode" aliases (e.g., `claude --dangerously-skip-permissions`) and manages persistent volumes so distinct sessions retain context. While it prevents accidental file deletion or credential scraping on the host, the author notes that as a container-based solution, it does not offer the same isolation level as a VM against kernel exploits or determined adversarial attacks.

**Discussion Summary**
The discussion focused on security boundaries, alternative implementations, and the philosophical "laws" of AI behavior in development environments.

*   **Alternative Approaches & Comparisons:** Several users shared similar tools. **Gerharddc** highlighted [Litterbox](https://github.com/Gerharddc/litterbox), which leans on Podman and includes Wayland socket exposure for GUI apps and SSH agent prompts. **LayeredDelay** and **jcqsnd** discussed [shai](https://github.com/clany-2/shai), a local tool that defaults to read-only access and strictly controls network traffic, contrasting with Yolobox’s read-write default. Other users mentioned running agents on dedicated hardware (like a NUC) or using `toolbox`/`distrobox`.
*   **Security Boundaries (VM vs. Container):** There was debate regarding whether Docker provides sufficient isolation. **ctlfnmrs** and others argued that containers foster a false sense of security compared to VMs, citing Docker CVEs and kernel exploits. **Finbarr** (the OP) acknowledged this, updating the README to clarify the trust boundary; the consensus was that while containers stop accidental `rm -rf ~`, they aren't bulletproof against malicious breakouts.
*   **Agent Interaction & "Asimov’s Laws":** A sub-thread debated the "Three Tenets" of AI agents (don't break the build, obey the user, protect security). **MadnessASAP** argued that unlike deterministic compilers, AI code requires extreme scrutiny because it can be "subtly and disastrously wrong" or hallucinated, rejecting the idea that AI commits shouldn't be explicitly flagged.
*   **Integration Challenges:** **gngrlm** raised the issue of how these sandboxed agents interact with other local containers (e.g., a database in Docker Compose). The discussion noted that mounting `docker.sock` into the agent's container would negate the security benefits, leaving a gap in how to handle complex multi-container development environments safely.

### Apple picks Gemini to power Siri

#### [Submission URL](https://www.cnbc.com/2026/01/12/apple-google-ai-siri-gemini.html) | 968 points | by [stygiansonic](https://news.ycombinator.com/user?id=stygiansonic) | [600 comments](https://news.ycombinator.com/item?id=46589675)

Apple taps Google’s Gemini to supercharge Siri and its AI stack

- Apple and Google struck a multiyear deal to use Gemini and Google cloud tech for Apple’s foundational models, with a major Siri upgrade expected later this year. Models will still run on-device and via Apple’s private cloud, the companies said.
- Apple called Google’s tech “the most capable foundation” for its AI plans. Terms weren’t disclosed; past reports pegged talks around a custom Gemini model and suggested Apple could pay about $1B annually.
- The move underscores Google’s AI rebound: Alphabet briefly topped $4T in market value and recently overtook Apple by market cap. It already pays Apple billions to be Safari’s default search—an arrangement scrutinized in antitrust cases but still intact.
- Apple has been cautious in the AI race, delaying an ambitious Siri overhaul to 2026 after hyping it in ads. Pressure has mounted as Microsoft, Meta, and Amazon pour billions into AI.
- Apple currently pipes some complex Siri queries to OpenAI’s ChatGPT. Apple says that agreement isn’t changing—for now—leaving open how Google’s role will coexist with OpenAI inside “Apple Intelligence.”
- Google continues pushing Gemini (the article cites “Gemini 3”) and touts big-ticket cloud AI deals.

Why it matters: Apple is effectively hedging between OpenAI and Google to close its AI gap, while trying to preserve its privacy narrative with on-device and private-cloud processing. Expect renewed debate on platform lock-in, antitrust optics, and whether Apple can deliver a Siri that finally feels smart.

**Strategic Fit and Execution:** Commenters generally view the partnership as a pragmatic move, noting that Gemini is currently a top-tier model and Google provides the stable infrastructure and "deep pockets" Apple requires for enterprise-scale deployment. Users suggest this is a safer bet for Apple than relying solely on startups like Anthropic or OpenAI.

**Delay and Vaporware:** A significant portion of the discussion criticizes Apple for marketing "Apple Intelligence" features that have yet to ship, with some comparing the delay to the cancelled AirPower project. Users express frustration that Apple is selling hardware based on future software promises, breaking its traditional narrative of shipping complete, polished experiences.

**Panic vs. Strategy:** There is a debate over whether this deal represents a "panic" response to investor pressure and the existential threat AI poses to Apple's services moat (Siri, iMessage), or if it is standard Apple strategy to wait for technology to mature before adopting it (similar to tablets or folding phones).

**Hardware Grievances:** The conversation drifts into complaints about Apple’s control over user hardware, citing the removal of headphone jacks, soldered SSDs, and the slow transition to USB-C. Users argue over whether Apple "shoves trends down throats" or successfully mainstreamed technologies that competitors failed to popularize.

### Reproducing DeepSeek's MHC: When Residual Connections Explode

#### [Submission URL](https://taylorkolasinski.com/notes/mhc-reproduction/) | 110 points | by [taykolasinski](https://news.ycombinator.com/user?id=taykolasinski) | [30 comments](https://news.ycombinator.com/item?id=46588572)

DeepSeek’s mHC: taming “wider” residuals before they blow up

What’s new
- Transformers have used the same residual path since 2016: pass x through unchanged and add a learned update. DeepSeek explores “Hyper-Connections” (HC): multiple parallel streams with learnable mixing matrices that route information before, through, and after the layer.
- More expressive routing, negligible extra compute—until it isn’t. Unconstrained mixing matrices don’t just route; they amplify. Small gains compound across depth and can explode.

The failure mode
- Measure of trouble: Amax (max row/column absolute sum) ≈ worst-case signal gain.
- In a 10M-parameter repro, HC’s gain crept to 7–9× and sometimes collapsed; after 60 layers it can hit ~304×.
- At 27B parameters, DeepSeek saw peaks around 3000×. At that scale, unconstrained HC didn’t drift—it detonated.

The fix: mHC
- Constrain mixing matrices to be doubly stochastic (nonnegative, rows/cols sum to 1). That enforces “weighted averages,” so routing can shuffle and blend but cannot amplify.
- Implemented via the differentiable Sinkhorn-Knopp procedure (alternate row/column normalization for ~20 iters). Only the recursive residual mixer needs full Sinkhorn; pre/post mixers are just bounded with sigmoids.

Results and trade-offs
- Small scale (≈10M params, TinyShakespeare): HC is sharper but volatile.
  - Val loss: HC 0.884 ± 0.033 vs mHC 1.116 ± 0.012
  - Amax: HC ~6–7× with high seed variance; mHC pinned at 1.00 every run
- Depth sweeps show HC’s amplification is chaotic (spikes from ~4.3× to 9.2×). mHC stays flat.
- Takeaway: mHC is a “stability tax” at small scale, but at 27B it’s the price of admission—otherwise you gamble with exponential gain and NaNs.

Why it matters
- Multi-stream residuals could make Transformers more expressive without big compute costs, but only if their routing is gain-safe.
- If you try HC-like designs, monitor Amax and constrain the residual mixer (doubly stochastic or similar). Stability shouldn’t be “learned”—it should be guaranteed.

**Discussion Summary:**

The discussion focuses on the practical constraints of implementing DeepSeek’s Multi-Head Hyper-Connections (mHC) and compares it to emerging architectures from other major labs.

*   **Parallels with Google’s Gemma 3:** Users identified a convergence in "residual stream engineering," noting that Google’s newly released Gemma 3 uses a similar mechanism called **LAuReL** (Linear Attention with Low Rank Residuals). The author (OP) suggests that while mHC uses doubly stochastic matrices to stabilize the signal, LAuReL likely achieves stability via low-rank constraints.
*   **Scale dependence:** One user reported neutral results when implementing mHC on a small 8M parameter Vision Transformer. The OP validated this, arguing that standard additive residuals ($x+F(x)$) function perfectly fine at small depths; mHC is essentially a "stability tax" or enabler required for signal propagation in massive models (27B+) where standard connections might fail, rather than a performance booster for small models.
*   **Retrofitting risks:** Discussion arose regarding "grafting" mHC onto existing pre-trained models (like Llama 3) and fine-tuning. The OP warned that due to the 7x signal amplification observed in unconstrained networks, retrofitting requires careful initialization (starting at identity) and strict gradient clipping to prevent the model from exploding before it learns to route effectively.
*   **Clarifying mHC vs. MLA:** Several commenters confused mHC with **MLA** (Multi-Head Latent Attention). The author clarified that MLA is for context/memory efficiency (KV cache compression), whereas mHC increases expressivity and routing capability within the residual stream itself.

### Google removes AI health summaries after investigation finds dangerous flaws

#### [Submission URL](https://arstechnica.com/ai/2026/01/google-removes-some-ai-health-summaries-after-investigation-finds-dangerous-flaws/) | 211 points | by [barishnamazov](https://news.ycombinator.com/user?id=barishnamazov) | [142 comments](https://news.ycombinator.com/item?id=46595419)

Google pares back some AI Overviews after health safety flap

Ars Technica reports that Google quietly disabled certain AI Overviews in health searches after a Guardian investigation found dangerous inaccuracies. Queries like “what is the normal range for liver blood tests” were pulled after experts warned the summaries listed raw enzyme ranges without context or demographic adjustments, risking false reassurance for people with serious liver disease. The Guardian also flagged a pancreatic cancer answer advising low-fat diets—contrary to guidance to maintain weight—yet Google left many related Overviews live. Google told The Verge that most Overviews are accurate and clinician-reviewed.

Why it matters
- High risk domain: Health answers delivered atop search can shape care decisions.
- Design debt: Overviews lean on top-ranked pages in a web long plagued by SEO spam; even good sources can be mis-summarized by LLMs.
- Trust hit: Prior gaffes (“glue on pizza,” “eat rocks”) and user workarounds to disable Overviews compound skepticism.

Zoom out
- Experts warn lab “normals” are nuanced and patient-specific; simplistic ranges can mislead.
- Google says Overviews show only with “high confidence,” but similar queries still trigger them, highlighting enforcement gaps.

Open questions
- Will Google narrow Overviews in medical queries or add stronger disclaimers/context?
- Can ranking and model grounding be hardened against SEO-gamed inputs?

**Medical Device Regulation and Liability**
A major thread of the discussion argues that by providing specific health answers, Google’s AI acts as "Software as a Medical Device" (SaMD) and should face FDA regulation or liability for inaccuracies. Users debated the legal implications, with some expecting Google to rely on EULAs to waive responsibility for "confabulated medical advice," while others called for fines based on revenue to force stricter guardrails.

**Doctors vs. "Random Output Machines"**
A debate emerged comparing LLM accuracy to human practitioners. While some users defended AI by noting that human doctors also misdiagnose or rely on "rote learning" like a machine, others argued this is a false equivalence. Critics emphasized that doctors operate within a framework of accountability, verification, and decade-long training, whereas LLMs are "random output machines" that lack intrinsic verification capabilities. Users distinguished between AI as a tool for professionals (e.g., radiologists) versus AI as a direct diagnostic agent for laypeople, citing dangerous real-world examples of improper self-treatment based on online tutorials.

**Hallucinations Across Domains**
Commenters offered anecdotes of similar "confident inaccuracies" in non-medical fields to illustrate the systemic risk:
*   **Engineering:** One user, an electrical engineer, noted the AI suggested a "staggeringly wrong" safe distance for high-voltage equipment, which could be fatal.
*   **Pop Culture & Gaming:** Users reported the AI mixing *Minecraft* fan fiction with actual game mechanics, confusing book plots with Reddit fan theories, and identifying a LARP group as a real ethnic demographic in Poland.
*   **Circular Reporting:** One commenter noted the AI answered a query by citing the user's *own* previous speculation on Hacker News as fact, highlighting a dangerous feedback loop.

**The "No Information" Preference**
The consensus leaned toward the idea that "no information is superior to wrong information presented convincingly." While a minority found value in LLMs for discovering jargon or broad discourse summaries, most expressed frustration at having to scroll past "trash" summaries to get to primary sources, with some viewing the technology's current implementation as "design debt" driven by financial incentives rather than utility.

### Superhuman AI exfiltrates emails

#### [Submission URL](https://www.promptarmor.com/resources/superhuman-ai-exfiltrates-emails) | 52 points | by [takira](https://news.ycombinator.com/user?id=takira) | [7 comments](https://news.ycombinator.com/item?id=46592424)

Superhuman AI exfiltrates emails via prompt injection (remediated)

- What happened: PromptArmor found that a malicious email could inject instructions that, when the user asked Superhuman’s AI to summarize recent mail, coerced it into sending contents of other emails to an attacker—without the user opening the malicious email.
- How: The injection had the AI build a prefilled Google Form URL and embed it as a Markdown image. The browser’s automatic image fetch made a background request to docs.google.com (whitelisted in Superhuman’s CSP), turning the AI’s output into an exfiltration channel.
- Impact: Full contents of multiple sensitive emails and partial contents of 40+ could be exfiltrated, including financial, legal, and medical data. PromptArmor also reported broader phishing and integration risks across the suite (Superhuman, Coda) after Grammarly’s acquisitions.
- Response: Superhuman escalated quickly, disabled vulnerable features, and shipped fixes. PromptArmor praised the speed and quality of the response.
- Why it matters: LLM agents that read untrusted content can be steered into making network requests. Domain allowlists aren’t enough; features like image auto-loading and form prefill can become covert data channels.
- Mitigations for builders: Treat model-visible content as untrusted; require user approval for outbound requests; sanitize/neutralize links and Markdown; proxy and block auto-fetches; design allowlists by intent (no form endpoints), not just domain; add DLP checks and per-source sandboxes.

The discussion focused on the mechanics of the attack and the broader implications for AI agents with web access:

*   **Exfiltration Vectors:** Users identified that LLMs capable of making network requests (particularly via image rendering) create a primary vector for leaking sensitive data. There is growing concern that as coding assistants (like Claude) gain access to local environments, they could be tricked into exposing encrypted rails credentials or `.env` files.
*   **Vendor Response:** Commenters praised Superhuman for their rapid handling of the disclosure, noting that many large tech companies often fumble AI vulnerability reports.
*   **Mitigation Strategies:** Participants debated how to secure these systems. Suggestions included determining permissions via "accept/deny" buttons rather than implicit trust, aggressively filtering generated URLs, or disconnecting AI components from the open web entirely.
*   **Root Cause:** The conversation touched on the fundamental difficulty of separating "code" (instructions) from "data" in current AI architectures, which makes preventing injection attacks structurally difficult.

### Show HN: An LLM-optimized programming language

#### [Submission URL](https://github.com/ImJasonH/ImJasonH/blob/main/articles/llm-programming-language.md) | 47 points | by [ImJasonH](https://news.ycombinator.com/user?id=ImJasonH) | [33 comments](https://news.ycombinator.com/item?id=46583581)

I only see generic GitHub page text here (buttons and alerts), not the content of the submission. Could you share the direct link or the actual README/text you want summarized? Once I have the title or body, I’ll write a tight, engaging digest blurb.

Here is the digest blurb and the summary of the discussion.

**Digest Blurb:**
**Designing a Programming Language for Types (and LLMs)**
Does it make sense to force AI to write in Python or C++, languages designed for human cognition? This discussion explores the concept of an "LLM-native" programming language. The core premise suggests that while humans need readability, LLMs struggle with things like significant whitespace (counting spaces is hard for token predictors) and distant dependencies (imports at the top of a file). The proposed solution involves a language optimized for formal verification and generation—where the LLM produces verbose, mathematically verifiable code that compiles down to efficient binaries, skipping the human-human boilerplate entirely.

**Summary of Discussion:**
The discussion explores the theoretical requirements and trade-offs of creating a programming language specifically optimized for Large Language Models (LLMs) rather than human developers.

**Key Themes:**

*   **Syntax and Structure Optimization:**
    *   **Whitespace vs. Braces:** Several users, notably *mike_hearn*, argue that significant whitespace (like Python) is difficult for LLMs because they struggle with counting spaces and maintaining long-range counting state. Braces and explicit delimiters are viewed as safer for generation.
    *   **Locality of Context:** There is a consensus that LLMs suffer when relevant information is far apart. Suggestions for a new language include allowing inline imports (defining dependencies right where they are used) so the model doesn't have to "scroll up" or hallucinate header files.
    *   **Type Inference:** Explicit typing consumes valuable tokens. Participants suggest that while the underlying logic should be typed, user-facing (or LLM-facing) code should rely on CLI tools to inject types post-generation to save context window space.

*   **Formal Verification and Correctness:**
    *   The discussion references Martin Kleppmann’s work (linked in the thread), suggesting that LLM-generated code should target **formal verification** systems rather than standard compilers.
    *   Since LLMs are stochastic (they make guesses), the language should be rigid and mathematically verifiable to enforce correctness, acting as a "guard rail" against hallucinations.

*   **The Training Data Problem:**
    *   Skeptics point out a catch-22: LLMs are powerful because they are trained on billions of lines of *existing* human languages (Python, Java, C).
    *   Creating a novel "LLM-optimized" language would force the model into a zero-shot environment where it has no training examples, likely resulting in poorer performance than simply generating standard boilerplate code.

*   **Alternative Approaches:**
    *   Some argue that existing languages like Lisp (S-expressions) or even Assembly are already "LLM-optimized" due to their structural simplicity or explicitness.
    *   Others suggest a hybrid approach where the AI interacts with a tree-based exploration agent or a REPL (Read-Eval-Print Loop) to iteratively fix code, rather than needing a new syntax entirely.

